<?php

namespace Darkish\CategoryBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Darkish\CategoryBundle\Entity\MainTree;
use Darkish\CategoryBundle\Entity\Record;
use Darkish\CategoryBundle\Entity\Cache\StoreCache;
use JMS\Serializer\SerializationContext;
use Symfony\Component\DependencyInjection\ContainerAwareInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;

/**
 * RecordRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class RecordRepository extends EntityRepository implements ContainerAwareInterface
{
    /**
     * @var ContainerInterface
     */
    private $container;

    public function getRecordsForCat(MainTree $tree) {
        $mainTreeRepo = $this->getEntityManager()->getRepository('DarkishCategoryBundle:MainTree');

        $children = $mainTreeRepo->getTreeChildren($tree);

        $treesIds = array();
        $treesIds[] = $tree->getId();
        foreach($children as $child) {
            $treesIds[] = $child->getId();
        }
        die(print_r($treesIds,true));
        $recordQuery = $this->createQueryBuilder('r');
        $recordQuery->join('r.maintrees', 'rt');
        $recordQuery->join('rt.tree','t', 'WITH',$recordQuery->expr()->in('t.id', $treesIds))->distinct();
        $recordQuery->orderBy('r.lastUpdate', 'Desc');
        // $recordQuery->addOrderBy('nt.sort', 'Asc');

        return $recordQuery;
    }

    public function getRecordsForTreeIds(array $treesIds, array $centers) {

        if(count($treesIds) == 0) {
            $treesIds[] = 0;
        }


        $recordQuery = $this->createQueryBuilder('r');
        $recordQuery->join('r.maintrees', 'rt');
        $recordQuery->join('rt.tree','t', 'WITH',$recordQuery->expr()->in('t.id', $treesIds))->distinct();
        if(count($centers)) {
            $recordQuery->where('r.centerIndex in (:centers)')->setParameter('centers', $centers);
        }
        $recordQuery->orderBy('r.lastUpdate', 'Desc');
        // $recordQuery->addOrderBy('nt.sort', 'Asc');

        return $recordQuery;
    }



    public function generateStoreCache(Record $record, $serializer) {
        $storeInfo = $serializer
                        ->serialize($record, 'json', SerializationContext::create()
                                                        ->setGroups(["api.store", "file.details"])
                                        );
        $storeInfo = $serializer->deserialize($storeInfo, 'array', 'json');

        $groups = $record->getMarketGroups();


        $allProducts = [];
        foreach ($groups as $key => $group) {
            $products = $this->getEntityManager()->getRepository('DarkishCategoryBundle:Product')
                ->findBy(['group' => $group->getId()]);

            $allProducts[$group->getId()] = $products;
//            $products[$group->getId()] = ['test', 'test2'];
        }

        $serializedAllProducts = $serializer
            ->serialize($allProducts, 'json', SerializationContext::create()
                ->setGroups(["api.list","file.details", "api.store"]));
        $allProducts = $serializer->deserialize($serializedAllProducts, 'array', 'json');


        return [
            'store_info' => $storeInfo,
            'products' => $allProducts
        ];
    }


    public function getStoreInfo(Record $record, $serializer) {
        $em = $this->getEntityManager();
        $storeCache = $em->getRepository('DarkishCategoryBundle:Cache\StoreCache')
            ->findOneBy(['recordId' => $record->getId()]);

        if(!$storeCache ) {
            $storeCache = new StoreCache();
            $storeCache->setJson($this->generateStoreCache($record, $serializer));
            $storeCache->setRecordId($record);
            if($record->getMarketLastUpdate()) {
                $record->setMarketLastCacheCreate($record->getMarketLastUpdate());
            } else {
                $now = new \DateTime();
                $record->setMarketLastCacheCreate($now);
                $record->setMarketLastUpdate($now);

            }
            $em->persist($storeCache);
            $em->persist($record);
            $em->flush();

        } elseif($record->getMarketLastUpdate() > $record->getMarketLastCacheCreate()) {
            $storeCache->setJson($this->generateStoreCache($record, $serializer));
            $record->setMarketLastCacheCreate($record->getMarketLastUpdate());
            $em->persist($storeCache);
            $em->persist($record);
            $em->flush();
        }

        return $storeCache;
    }

    /**
     * Sets the Container.
     *
     * @param ContainerInterface|null $container A ContainerInterface instance or null
     *
     * @api
     */
    public function setContainer(ContainerInterface $container = null)
    {
        $this->container = $container;
    }
}
